<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Game of Life</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl materials
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';

			const gridDimension = 50;
			const tileDimension = 10;
			const tileDepth = 20;

			let edges = {
				topRow: [],
				rightRow: [],
				bottomRow: [],
				leftRow: []
			};

			let container, stats;

			let camera, scene, renderer;
			let pointLight;

			let objects = [], materials = [];

			let cell = {
				h: 0.0,
				s: 0.0,
				l: 0.0,
				age: 0
			}

			let cellsMatrix = Array(gridDimension ** 2)
			
			for (var i = 0; i < cellsMatrix.length; i++) {
				cellsMatrix[i] = {h: 0.0, s: 0.0, l: 0.0, age: 0}
			}
			
			//let cellsMatrix = [
			//	1, 0, 0, 0,
			//	0, 1, 0, 0,
			//	0, 0, 1, 0,
			//	0, 0, 0, 1
			//];

			init();
			animate();

			function setEdges(gridDimension) {			
				//This should be a method of the edges object that runs on object init
				for (var i = 0; i < (gridDimension ** 2); i++) {
					let j = i+1;
					if (i < gridDimension) {
						edges.topRow.push(i)
					}
					if (i > ((gridDimension ** 2)-gridDimension)) {
						edges.bottomRow.push(i)
					}
					if (j % gridDimension === 0) {
						edges.rightRow.push(i)
					}
					if (i % gridDimension === 0) {
						edges.leftRow.push(i)
					}					
				}
			}

			function testEdges(gridDimension) {
				const allEdges = [...edges.topRow, ...edges.rightRow, ...edges.bottomRow, ...edges.leftRow];
				for (let i = 0; i < (gridDimension ** 2); i++) {
					if (allEdges.includes(i)) {
						materials[i].emissive.setHSL(0.0, 0.0, 1.0)
					}
					else {
						materials[i].emissive.setHSL(0.0, 0.0, 0.0)
					}
				}
			}	

			function randomColor(cellsMatrix,probability) {
				//Sets a percentage of the cells to a random color.
				//Probability is the chance of the change being applied to a cell (0-1)
				for (let i = 0; i < (gridDimension ** 2); i++) {
					if (Math.random() > probability) {
						cellsMatrix[i].h = Math.random();
						cellsMatrix[i].s = Math.random();
						cellsMatrix[i].l = Math.random();
						cellsMatrix[i].age = 0;
					}
				}
				return cellsMatrix
			}

			function setGeo() {
				for (let i = 0; i < (gridDimension ** 2); i++) {
					//console.log(`cellsMatrix length is: ${cellsMatrix.length}`);
					//console.log(`Cell ${i} is: ${cellsMatrix[i].h}, ${cellsMatrix[i].s}, ${cellsMatrix[i].l}`);
					//console.log(`Materials length is: ${materials.length}`);
					materials[i].emissive.setHSL(cellsMatrix[i].h, cellsMatrix[i].s, cellsMatrix[i].l)
				}
			}		

			//function reverseCells() {
			//	for (let i = 0; i < (gridDimension ** 2); i++) {
			//		if (cellsMatrix[i] == 1) {
			//			cellsMatrix[i] = 0
			//		}
			//		else {
			//			cellsMatrix[i] = 1
			//		}
			//	}
			//}

			function evolveCells() {
				//If a cell is on,  and has three or more neighbors, it turns off
				//If a cell is off, and has no neighbors,            it turns on 

				/*
					0  1  2  3
					4  5  6  7
					8  9  10 11
					12 13 14 15

					0  1  2  3  4
					5  6  7  8  9
					10 11 12 13 14
					15 16 17 18 19
					20 21 22 23 24
				*/

				//const topRow = [0,1,2,3];
				//const rightRow = [3,7,11,15];
				//const bottomRow = [12,13,14,15];
				//const leftRow = [0,4,8,12];

				let neighborsMatrix = [];

				for (let i = 0; i < 16; i++) {
					//Get number of neighbors for this cell
					let neighbors = 0;
					//North
					if (cellsMatrix[i-4] == 1) {
						neighbors++
					}
					//North West
					if ( (cellsMatrix[i-3] == 1) && !rightRow.includes(i) ) {
						neighbors++
					}	
					//West
					if ((cellsMatrix[i+1] == 1) && !rightRow.includes(i) ) {
						neighbors++
					}		
					//South West
					if ((cellsMatrix[i+5] == 1) && !rightRow.includes(i) ) {
						neighbors++
					}			
					//South
					if (cellsMatrix[i+4] == 1) {
						neighbors++
					}
					//South East
					if ((cellsMatrix[i+3] == 1) && !leftRow.includes(i) ) {
						neighbors++
					}	
					//East
					if ((cellsMatrix[i-1] == 1) && !leftRow.includes(i) ) {
						neighbors++
					}	
					//North East
					if ((cellsMatrix[i-5] == 1) && !leftRow.includes(i) ) {
						neighbors++
					}	

					neighborsMatrix[i] = neighbors																														
				}

				for (let i = 0; i < 16; i++) {
					//Update matrix
					if ((cellsMatrix[i] == 1) && (neighborsMatrix[i] > 2)) {
						cellsMatrix[i] = 0
					}	
					if ((cellsMatrix[i] == 0) && (neighborsMatrix[i] == 0)) {
						cellsMatrix[i] = 1
					}
				}
			}			

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.set( 0, 1500, 0 );
				camera.up = new THREE.Vector3(1,0,1);
				camera.lookAt(new THREE.Vector3(0,0,0));
				

				scene = new THREE.Scene();

				// Grid
				//let helper = new THREE.GridHelper( 1000, 40, 0x303030, 0x303030 );
				//helper.position.y = - 75;
				//scene.add( helper );

				// Materials
				for (let i = 0; i < (gridDimension ** 2); i++) {
					materials.push( new THREE.MeshLambertMaterial( { color: 0x333333 } ) )
				}

				setEdges(gridDimension);
				//testEdges(gridDimension);
				setGeo();

				/*
				materials.push( new THREE.MeshLambertMaterial( { color: 0x003300 } ) );
				materials.push( new THREE.MeshLambertMaterial( { color: 0x006600 } ) );
				materials.push( new THREE.MeshLambertMaterial( { color: 0x009900 } ) );
                materials.push( new THREE.MeshLambertMaterial( { color: 0x00aa00 } ) );
				materials.push( new THREE.MeshLambertMaterial( { color: 0x000033 } ) );
				materials.push( new THREE.MeshLambertMaterial( { color: 0x000066 } ) );
				materials.push( new THREE.MeshLambertMaterial( { color: 0x000099 } ) );
                materials.push( new THREE.MeshLambertMaterial( { color: 0x0000aa } ) );
				materials.push( new THREE.MeshLambertMaterial( { color: 0x330000 } ) );
				materials.push( new THREE.MeshLambertMaterial( { color: 0x660000 } ) );
				materials.push( new THREE.MeshLambertMaterial( { color: 0x990000 } ) );
                materials.push( new THREE.MeshLambertMaterial( { color: 0xaa0000 } ) );      
				materials.push( new THREE.MeshLambertMaterial( { color: 0x330033 } ) );
				materials.push( new THREE.MeshLambertMaterial( { color: 0x660066 } ) );
				materials.push( new THREE.MeshLambertMaterial( { color: 0x990099 } ) );
                materials.push( new THREE.MeshLambertMaterial( { color: 0xaa00aa } ) );  
				*/                                         


				// Geometry

				//let geometry = new THREE.SphereBufferGeometry( 70, 32, 16 );
                let geometry = new THREE.BoxGeometry(tileDimension,tileDepth,tileDimension);

				for ( let i = 0, l = materials.length; i < l; i ++ ) {

					addMesh( geometry, materials[ i ] );

				}

				// Lights

				scene.add( new THREE.AmbientLight( 0x111111 ) );

				let directionalLight = new THREE.DirectionalLight( 0xffffff, 0.125 );

				directionalLight.position.x = Math.random() - 0.5;
				directionalLight.position.y = Math.random() - 0.5;
				directionalLight.position.z = Math.random() - 0.5;
				directionalLight.position.normalize();

				scene.add( directionalLight );

				pointLight = new THREE.PointLight( 0xffffff, 1 );
				scene.add( pointLight );

				pointLight.add( new THREE.Mesh( new THREE.SphereBufferGeometry( 4, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0xffffff } ) ) );

				//
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				//
				stats = new Stats();
				container.appendChild( stats.dom );

				//
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function addMesh( geometry, material ) {

				let mesh = new THREE.Mesh( geometry, material );

				mesh.position.x = ( objects.length % gridDimension ) * (tileDimension*1.1) - 280;
				mesh.position.z = Math.floor( objects.length / gridDimension ) * (tileDimension*1.1) - 280;

				
				//mesh.rotation.x = 45;
				//mesh.rotation.y = 0;
				//mesh.rotation.z = 45;
				

				objects.push( mesh );

				scene.add( mesh );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				let timer = 0.0001 * Date.now();

				
				//camera.position.x = Math.cos( timer ) * 1000;
				//camera.position.z = Math.sin( timer ) * 1000;

			 	//camera.lookAt( scene.position );

				/*
				for ( let i = 0, l = objects.length; i < l; i ++ ) {

					let object = objects[ i ];

					object.rotation.x += 0.02;
					object.rotation.y += 0.01;

				}

				
				materials[ materials.length - 1 ].emissive.setHSL( 0.05, 1, 0.35 * ( 0.5 + 0.5 * Math.cos( 35 * timer ) ) );
				materials[ materials.length - 2 ].emissive.setHSL( 0.10, 1, 0.35 * ( 0.5 + 0.5 * Math.sin( 35 * timer ) ) );
				materials[ materials.length - 3 ].emissive.setHSL( 0.15, 1, 0.35 * ( 0.5 + 0.5 * Math.cos( 35 * timer ) ) );
				materials[ materials.length - 4 ].emissive.setHSL( 0.20, 1, 0.35 * ( 0.5 + 0.5 * Math.sin( 35 * timer ) ) );
				materials[ materials.length - 5 ].emissive.setHSL( 0.25, 1, 0.35 * ( 0.5 + 0.5 * Math.cos( 35 * timer ) ) );
				materials[ materials.length - 6 ].emissive.setHSL( 0.30, 1, 0.35 * ( 0.5 + 0.5 * Math.sin( 35 * timer ) ) );
				materials[ materials.length - 7 ].emissive.setHSL( 0.35, 1, 0.35 * ( 0.5 + 0.5 * Math.cos( 35 * timer ) ) );
				materials[ materials.length - 8 ].emissive.setHSL( 0.40, 1, 0.35 * ( 0.5 + 0.5 * Math.sin( 35 * timer ) ) );
				materials[ materials.length - 9 ].emissive.setHSL( 0.45, 1, 0.35 * ( 0.5 + 0.5 * Math.cos( 35 * timer ) ) );
				materials[ materials.length - 10 ].emissive.setHSL( 0.50, 1, 0.35 * ( 0.5 + 0.5 * Math.sin( 35 * timer ) ) );
				materials[ materials.length - 11 ].emissive.setHSL( 0.55, 1, 0.35 * ( 0.5 + 0.5 * Math.cos( 35 * timer ) ) );
				materials[ materials.length - 12 ].emissive.setHSL( 0.60, 1, 0.35 * ( 0.5 + 0.5 * Math.sin( 35 * timer ) ) );
				materials[ materials.length - 13 ].emissive.setHSL( 0.65, 1, 0.35 * ( 0.5 + 0.5 * Math.cos( 35 * timer ) ) );
				materials[ materials.length - 14 ].emissive.setHSL( 0.70, 1, 0.35 * ( 0.5 + 0.5 * Math.sin( 35 * timer ) ) );
				materials[ materials.length - 15 ].emissive.setHSL( 0.75, 1, 0.35 * ( 0.5 + 0.5 * Math.cos( 35 * timer ) ) );
				materials[ materials.length - 16 ].emissive.setHSL( 0.80, 1, 0.35 * ( 0.5 + 0.5 * Math.sin( 35 * timer ) ) );
				*/


				pointLight.position.x = Math.sin( timer * 7 ) * 300;
				//pointLight.position.y = Math.cos( timer * 5 ) * 400;
				pointLight.position.y = 100;
				pointLight.position.z = Math.cos( timer * 3 ) * 300;

				renderer.render( scene, camera );

			}

			document.addEventListener('keydown', function(event) {
				if (event.code == 'Space') {
					//reverseCells();
					//evolveCells();
					
					cellsMatrix = randomColor(cellsMatrix,0.8);
					setGeo();

					/* for (let i = 0; i < 16; i++) {
						if (Math.random() > 0.5) 
						{
							materials[i].emissive.setHSL(0.0, 0.0, 0.0)
						}
						else 
						{
							materials[i].emissive.setHSL(0.0, 0.0, 1.0)
						}
					} */
				}
			});			

		</script>

	</body>
</html>
